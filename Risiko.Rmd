---
title: "Risiko!"
author: "Manuel Bottino"
date: "`r Sys.Date()`"
output: pdf_document
---
# Always set SEED!!!!

# Rules:
> Goal of the game -> You (the attacker) want to conquer your opponent’s territory (the defender), and you do so by using your army, made of units.You decide how many units to use in the attack, while the defender uses their available units in the territory.

Battle algorithm 
1. both players toss some dice (with six equiprobable faces). In particular, the attacker will throw three dice if the number of units at their disposal exceeds three. The same holds for the defender (we consider the European version, where the defender can toss up to three dice).

2. they sort their outcomes and compare the maximum values they scored. If the attacker’s highest value is strictly greater than the defender’s, the attacker LOSES a unit. Otherwise, the defender loses one.

3. they remove these dice and repeat the operation (comparing the second-highest values and so on). The first player that loses all their units is the loser of the battle.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
library(magrittr)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(ggpubr)
library(bookdown)
library(plotly)
library(rstanarm)
library(Cairo)
library(rgl)
library(plot3D)
library(effects)
library(MASS)
library(car)
library(faraway)
library(leaps)
library(ROCR)
library(RColorBrewer)
library(ISLR2)
library(e1071)
library(class)
library(reshape2)
```


a)
Fonte:https://stats.stackexchange.com/questions/262630/what-is-the-distribution-of-the-maximum-of-independent-non-identical-binomial-va
```{r}

X_i=sapply(1:6, function(i) (2*(i-1)+1)/36) # P(Z=z)

a=(6:1)
X_lessthanorequalto_Y=sapply(1:6, function(i) a[i]*X_i[i]*1/6)

1-sum(X_lessthanorequalto_Y)
```

b)

```{r}

War=function(att_units, def_units, dices_att, dices_def){
  while((att_units>0 & def_units>0)){
  
  
    
  dices=min(dices_att, dices_def)
  att_rand=sort(sample(1:6, min(att_units,3)), decreasing=T)[1:dices]
  def_rand=sort(sample(1:6, min(def_units,3)), decreasing=T)[1:dices]
  
  att_units=att_units-sum(def_rand>=att_rand)
  def_units= def_units- sum(att_rand>def_rand)
  
  }
  if(def_units<=0){
    return(1)
  }else{
    return(0)
  }
}


Risiko=function(att_units, def_units, sim=10000){


  #Set the number of dices
if(att_units>3){
    dices_att=3
  }else{
    dices_att=att_units
  }
  
if(def_units>3){
    dices_def=3
  }else{
    dices_def=def_units
  }
  

count=sapply(1:sim, function(i) War(att_units=att_units, def_units=def_units, dices_att=dices_att, dices_def=dices_def))

  return(sum(count)/sim)
}



Risiko(att_units=2, def_units=1, sim=50000)

a=c(1:14)
outcomes=outer(a, a, Vectorize(Risiko)) # apply the function Risiko to all possible combination of attackers and defender units from 1 to 14
typeof(outcomes)

heatmap_data <- ggplot(data = melt(outcomes)) + # melt() function from reshape2 library to go from a matrix to a well-structured database
  geom_tile(aes(x = Var2, y = Var1, fill = value), color = "white") +
  scale_fill_gradient(low = "blue", high = "red") +
  labs(x = "Defend units", y = "Attach units", fill = "Probability of winning (attacker)") +
  theme_minimal() # to make the plot look better

heatmap_data


a=3
b=1
a>0 & b>0
```


